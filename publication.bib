@phdthesis{izawa2023phd,
author  = {Yusuke Izawa},
title   = {Supporting multi-scope and multi-level compilation in a meta-tracing just-in-time compiler},
school  = {Tokyo Institute of Technology},
year    = {2023}
}
@mastersthesis{izawa2020master,
author  = {Yusuke Izawa},
title   = {Stack Hybridization: A Mechanism for Bridging Two Compilation Strategies in a Meta Compiler Framework},
school  = {Tokyo Institute of Technology},
year    = {2020},
}
@Article{izawa_et_al:DARTS.11.2.16,
  author =	{Izawa, Yusuke and Masuhara, Hidehiko and Bolz-Tereick, Carl Friedrich},
  title =	{{A Lightweight Method for Generating Multi-Tier JIT Compilation Virtual Machine in a Meta-Tracing Compiler Framework (Artifact)}},
  pages =	{16:1--16:4},
  journal =	{Dagstuhl Artifacts Series},
  ISSN =	{2509-8195},
  year =	{2025},
  volume =	{11},
  number =	{2},
  editor =	{},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/DARTS.11.2.16},
  URN =		{urn:nbn:de:0030-drops-233590},
  doi =		{10.4230/DARTS.11.2.16},
  annote = {refereed},
  note = {selected},
  keywords  = {JIT compiler, Adaptive RPython},
}
@article{takahashi2021ipsj-pro-paper,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {An approach to collect object graphs for data-structure live programming based on a language implementation framework},
note = {Presented at the IPSJ PRO 2021-3-(5) in November 2021.},
journal={Journal of Information Processing},
volume={30},
number={ },
pages={451-463},
year={2022},
date={2022-06-15},
doi={10.2197/ipsjjip.30.451},
abstract = {Data-structure live programming environments execute a program, collect object graphs (objects and their mutual references) created and modified during the execution, and visualize the graphs as a node-link diagram. Existing implementations collect object graphs by instrumenting checkpoints, which traverse reachable objects, into every necessary points in the program. Since the cost of each checkpoint is proportional to the number of existing objects, its overhead can be huge. This paper proposes (1) a method to collect object graphs by recording object creation and modification events into an efficient data structure, and (2) to implement the object graph collection mechanism by extending a language implemented on top of a language implementation framework.  As a result, the overhead of object graph collection is merely proportional to the number of object creation/modification operations in total. We implemented the proposed mechanism for the Kanon data-structure live programming environment by extending GraalJS, which is a JavaScript implementation on the Graal/Truffle language implementation framework. We compared our new implementation against the original Kanon, which is based on checkpointing, and confirmed that our implementation improves program execution (and data collection) speed, and has sufficiently small overheads to reconstruct object graphs.},
annote = {refereed},
note = {selected}
}
@article{izawa2022jot,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick AND Youyou Cong},
title = {Threaded Code Generation with a Meta-Tracing JIT Compiler},
year = 2022,
month = 2,
journal = {Journal of Object Technology},
issn = {1660-1769},
pages = {2:1-11},
doi = {10.5381/jot.2022.21.2.a1},
note = {Presented at the ICOOOLPS 2021 workshop in July 2021.},
numpages = 11,
archivePrefix = {arXiv},
eprint = {2106.12496},
abstract = {Language implementation frameworks, e.g., RPython and Truffle/Graal, are practical tools for creating efficient virtual machines, including a well-functioning just-in-time (JIT) compiler. It is demanding to support multitier JIT compilation in such a framework for language developers. This paper presents an idea to generate threaded code by reusing an existing meta-tracing JIT compiler, as well as an interpreter design for it. Our approach does not largely modify RPython itself but constructs an effective interpreter definition to enable threaded code generation in RPython. We expect our system to be extended to support multilevel JIT compilation in the RPython framework. We measured the potential performance of our threaded code generation by simulating its behavior in PyPy. We confirmed that our approach reduced code sizes by 80 \% and compilation times by 60 \% compared to PyPy's JIT compiler on average, and ran about 7 \% faster than the interpreter-only execution.},
annote = {refereed},
note = {selected}
}
@inproceedings{izawa2023splashposter,
author = {Izawa, Yusuke and Kadomoto, Junichiro and Irie, Hidetsugu and Sakai, Shuichi},
title = {A Functional Reactive Programming Language  for Wirelessly Connected Shape-Changeable Chiplet-Based Computers},
year = 2023,
date = {2023-08-30},
doi = {10.1145/3618305.3623608},
isbn = {979-8-4007-0384-3/23/10},
publisher = {Association for Computing Machinery},
booktitle = {SPLASH Companion 2023},
address = {New York, NY, USA},
numpages = 2,
location = {Cascais, Portugal},
series = {SPLASH Companion 2023},
annote = {refereed},
}
@inproceedings{izawa2022pepm,
author = {Izawa, Yusuke and Masuhara, Hidehiko and Bolz-Tereick, Carl Friedrich},
title = {Two-level Just-in-Time Compilation with One Interpreter and One Engine},
year = 2022,
address = {Virtual},
howpublished = {},
booktitle = {The ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
series = {PEPM 2022},
date = {2022-01-17},
note = {\textbf{Refereed}. Short paper. 7 pages},
archivePrefix = {arXiv},
eprint = {2201.09268},
url = {https://popl22.sigplan.org/details/pepm-2022-papers/3/Two-level-Just-in-Time-Compilation-with-One-Interpreter-and-One-Engine},
abstract = {Modern, powerful virtual machines such as those running Java or JavaScript support multi-tier JIT compilation and optimization features to achieve their high performance. However, implementing and maintaining several compilers/optimizers that interact with each other requires hard-working VM developers. In this paper, we propose a technique to realize two-level JIT compilation in RPython without implementing several interpreters or compilers from scratch. As a preliminary realization, we created adaptive RPython, which performs both baseline JIT compilation based on threaded code and tracing JIT compilation. We also implemented a small programming language with it. Furthermore, we preliminarily evaluated the performance of that small language, and our baseline JIT compilation ran 1.77x faster than the interpreter-only execution. Furthermore, we observed that when we apply an optimal JIT compilation for different target methods, the performance was mostly the same as the one optimizing JIT compilation strategy, saving about 40 \% of the compilation code size.},
annote = {refereed},
note = {}
}
@inproceedings{masuhara2020live,
author = {Hidehiko Masuhara AND Shusuke Takahashi AND Yusuke Izawa AND Youyou Cong},
title = {Toward a Multi-Language and Multi-Environment Framework for Live Programming},
year = 2020,
url = {http://liveprog.org/live-2020/Toward-a-Multi-Language-and-Multi-Environment-Framework-for-Live-Programming/},
series = {Live 2020},
address = {Virtual},
booktitle = {Proceedings of the 6th Workshop on Live Programming},
numpages = 5,
pages = {1-5},
note = {\textbf{Refereed}. 5 pages},
abstract = {While applications of live programming are expanding to more practical and professional domains, most live programming environments (LPEs) are still developed for a single target language with an original code editor.  We propose an implementation framework for developing LPEs so that we can minimize efforts on implementing an LPE for a different target language and an existing code editor/IDE.  Our idea is to use a meta-JIT language implementation framework (e.g., Graal/Truffle and RPython) and LSP to separate core live programming implementations from language-specific and editor/IDE specific implementations.  This paper takes the Kanon live programming environment as a concrete example and discusses how we can design the framework to accommodate the features of Kanon.  Although the framework design is still underway, the paper presents a sketch of the framework APIs for separating language-specific functions and clarifies the requirements to LSP.},
annote = {refereed}
}
@inproceedings{10.1145/3328433.3328439,
author = {Izawa, Yusuke and Masuhara, Hidehiko and Aotani, Tomoyuki},
title = {Extending a Meta-Tracing Compiler to Mix Method and Tracing Compilation},
year = {2019},
date= {2019-04-02},
isbn = {9781450362573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3328433.3328439},
abstract = {Meta-interpreter-based just-in-time compiler frameworks provide a convenient way for language designers to implement efficient virtual machines. Those frameworks either employ tracing-based or method- (or partial evaluation) based strategies, which have their own pros and cons. This paper proposes an approach to enable both tracing- and method-based compilation so that the runtime can selectively apply an appropriate strategy to different parts of a program. The proposal basically extends a meta-tracing compiler to method-based compilation by roll backing at conditional branches, trace-splitting at loop entries, and not following at function calls. As a proof-of-concept, we implemented a tiny meta-tracing compiler in MinCaml by following the RPython's architecture and extended it to support both tracing- and method-based compilation.},
booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
articleno = {5},
numpages = {3},
pages = {1-3},
note = {\textbf{Refereed}. 3 pages},
keywords = {language implementation frameworks, tracing JIT compilation, RPython},
location = {Genova, Italy},
series = {Programming 2019},
annote = {refereed},
note = {}
}
@inproceedings{10.1145/3328433.3328466,
author = {Izawa, Yusuke},
title = {BacCaml: The Meta-Hybrid Just-in-Time Compiler},
year = {2019},
date= {2019-04-02},
isbn = {9781450362573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3328433.3328466},
abstract = {Meta-interpreter-based just-in-time compiler frameworks are useful to conveniently build a language runtime with reasonable execution performance.},
booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
articleno = {32},
numpages = {3},
pages = {1-3},
note = {\textbf{Refereed}. \textbf{Awarded [*]}. 3 pages},
location = {Genova, Italy},
series = {Programming 2019},
annote = {refereed},
note = {}
}
@inproceedings{izawa2019jssst,
organization = {{J}apan Society for Software Science and Technology ({JSSST})},
location = {Shibaura Institute of Technology, Tokyo, Japan},
editor = {Kei Ito},
year = {2019},
date = {2019-08-27},
booktitle = {Proceedings of the 36th JSSST Annual Conference},
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani AND Youyou Cong},
title = {A Stack Hybridization for Meta-hybrid Just-in-time Compilation},
pages = {No.~2-L},
pages = {1--9},
review = {false},
keywords = {PyPy, BacCaml, MinCaml, RPython},
url = {http://jssst.or.jp/files/user/taikai/2019/proceedings.html},
abstract = {Meta-interpreter-based language implementation frameworks, such as RPython and Truffe/Graal, are convenient tool for implementing state-of-the-art virtual machines. Those frameworks are classified into trace-based and method- (or ast-) based strategies. RPython uses a trace-based policy to compile straight execution paths, while Truffe/Graal leverages method invocation to compile entire method bodies. Each approach has its own advantages and disadvantages. The trace-based strategy is good at compiling pro- grams with many branching possibilities and able to reduce the size of compiled code, but it is weak at programs with varying control-flow. The method-based strategy is robust with the latter type of programs but it needs thorough method-inlining management to achieve excellent performance. To take advantage of both strategies, we propose a meta-hybrid compilation technique to integrate trace- and method-based compilations, as well as a proof-of-concept implementation called BacCaml. To achieve this goal, we develop a stack hybridization mechanism which makes it possible to coordinate trace- and method-based meta JIT compilation. In the implementation, we extend RPython's architecture and introduced a special syntax for realizing this system in a single interpreter definition.},
annote = {nonrefereed}
}
