@inproceedings{izawa2025uist,
  author={Izawa, Yusuke and Kadomoto, Junichiro and Irie, Hidetsugu},
  booktitle={37th ACM Symposium on User Interfance and Software Technology (UIST)},
  title={VisMorph: A Live Programming Environment for Shape-Adaptive Computers},
  year={2025},
  volume={},
  number={},
  pages={},
  note = {selected},
  keywords={Live Programming},
  doi={},
  annote    =	{refereed},
  note      =	{selected},
}

@inproceedings{izawa2025ecoop,
author =	{Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick},
title  =	{A Lightweight Method for Generating Multi-{T}ier {JIT} Compilation Virtual Machine with a Meta-{T}racing Compiler Framework},
year   =	{2025},
booktitle =	{39th European Conference on Object-Oriented Programming (ECOOP 2025)},
series    =	{Leibniz International Proceedings in Informatics (LIPIcs)},
year      =	{2025},
date      = {2025-06-30},
keywords  = {JIT compiler, Adaptive RPython},
pages     = {to appear},
publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
address   =	{Bergen, Norway},
eprint    = {https://doi.org/10.48550/arXiv.2504.17460},
abstract  = {
                  Meta-compiler frameworks can generate high-performance virtual
                  machines (VMs) from interpreter definitions. Despite the
                  success of frameworks such as RPython and Graal/Truffle,
                  creating multi-tier JIT compilation VMs within these
                  frameworks remains challenging. Traditional high-performance
                  VMs address this by using multiple  compilers that are
                  optimized for different trade-offs between compilation speed
                  and code quality. Replicating this structure in meta-compiler
                  frameworks, however, involves  substantial development effort.

                  We propose an approach, in the context of a meta-compiler framework, to adding a
                  lightweight compiler that takes a different compilation
                  strategy from an existing  heavyweight compiler without
                  requiring a new JIT compiler backend. By treating interpreter
                  definitions as not only specifications for language semantics but also as
                  compilation strategies, our approach enables RPython to
                  generate the essential components for a multi-tier JIT
                  compilation VM. We validate our approach with 2SOM, a
                  two-level compilation VM for Simple Object Machine. 2SOM
                  incorporates two JIT compilers: a tier-1 threaded code
                  generator that quickly produces subroutine threaded code for
                  warm-up phase, and tier-2 tracing JIT compiler that optimizes
                  frequently executed loops.  Our performance evaluation, using
                  a program with a realistic workload,  showed that 2SOM
                  improved warm-up performance by 15\% from an RPython-based VM
                  in compensation for a peak performance reduction of merely
                  5\%.
            },
URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2025.16},
doi =		{10.4230/LIPIcs.ECOOP.2025.16},
annote    =	{refereed},
note      =	{selected},
}
@inproceedings{izawa2024apsec,
author = {Yusuke Izawa AND Junichiro Kadomoto AND Hidetsugu Irie},
title = {Designing a Reactive Programming Language for Shape-Adaptive Computers},
publisher = {IEEE},
booktitle = {31st Asia-Pacific Software Engineering Conference, Early Research Achievement (APSEC 2024 ERA)},
location = {Chongquing, China},
year = {2024},
month = 12,
date  = {2024-12-03},
keywords = {MorphLang},
annote = {refereed},
numpages = 5,
abstract = {The advent of shape-adaptive computers, which consist of microscale
            devices that can  wirelessly interconnect and dynamically
            reconfigure their shapes and functions, presents new
            challenges for software development. Existing programming
            environments and languages are not well-suited for managing
            the complex state interactions and asynchronous processes
            inherent in such systems. In response to these challenges, we
            propose the design and current status of MorphLang, a
            declarative programming language specifically designed for
            shape-adaptive computers. MorphLang abstracts the complexities
            of device interaction, enabling developers to focus on
            high-level behavior  definitions without the need for
            intricate state management. Through a practical example, we
            demonstrate MorphLang's ability to handle dynamic node
            interactions effectively, paving the way for more efficient
            and innovative applications in shape-adaptive computing. Our
            approach not only simplifies the development process but also
            lays the groundwork for future advancements in this emerging field.},
note = {selected},
pages = {to appear}
}
@inproceedings{izawa2020dls,
author = {Izawa, Yusuke and Masuhara, Hidehiko},
title = {Amalgamating Different JIT Compilations in a Meta-Tracing JIT Compiler Framework},
year = {2020},
date = {2020-11-17},
isbn = {9781450381758},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3426422.3426977},
abstract = {Most virtual machines employ just-in-time (JIT) compilers to achieve high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner.  In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework.  We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture.  We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Symposium on Dynamic Languages},
pages = {1–15},
numpages = {15},
keywords = {JIT compiler, RPython, meta-tracing JIT compiler, language implementation framework},
location = {Virtual, USA},
series = {DLS 2020},
note = {\textbf{Refereed}. 15 pages},
annote = {refereed},
note = {selected}
}
