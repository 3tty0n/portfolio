@phdthesis{izawa2023phd,
author  = {Yusuke Izawa},
title   = {Supporting multi-scope and multi-level compilation in a meta-tracing just-in-time compiler},
school  = {Tokyo Institute of Technology},
year    = {2023}
}
@mastersthesis{izawa2020master,
author  = {Yusuke Izawa},
title   = {Stack Hybridization: A Mechanism for Bridging Two Compilation Strategies in a Meta Compiler Framework},
school  = {Tokyo Institute of Technology},
year    = {2020},
}
@Article{izawa_et_al:DARTS.11.2.16,
  author =	{Izawa, Yusuke and Masuhara, Hidehiko and Bolz-Tereick, Carl Friedrich},
  title =	{{A Lightweight Method for Generating Multi-Tier JIT Compilation Virtual Machine in a Meta-Tracing Compiler Framework (Artifact)}},
  pages =	{16:1--16:4},
  journal =	{Dagstuhl Artifacts Series},
  ISSN =	{2509-8195},
  year =	{2025},
  volume =	{11},
  number =	{2},
  editor =	{},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/DARTS.11.2.16},
  URN =		{urn:nbn:de:0030-drops-233590},
  doi =		{10.4230/DARTS.11.2.16},
  annote = {refereed},
  note = {selected}
}
@article{takahashi2021ipsj-pro-paper,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {An approach to collect object graphs for data-structure live programming based on a language implementation framework},
note = {Presented at the IPSJ PRO 2021-3-(5) in November 2021.},
journal={Journal of Information Processing},
volume={30},
number={ },
pages={451-463},
year={2022},
doi={10.2197/ipsjjip.30.451},
abstract = {Data-structure live programming environments execute a program, collect object graphs (objects and their mutual references) created and modified during the execution, and visualize the graphs as a node-link diagram. Existing implementations collect object graphs by instrumenting checkpoints, which traverse reachable objects, into every necessary points in the program. Since the cost of each checkpoint is proportional to the number of existing objects, its overhead can be huge. This paper proposes (1) a method to collect object graphs by recording object creation and modification events into an efficient data structure, and (2) to implement the object graph collection mechanism by extending a language implemented on top of a language implementation framework.  As a result, the overhead of object graph collection is merely proportional to the number of object creation/modification operations in total. We implemented the proposed mechanism for the Kanon data-structure live programming environment by extending GraalJS, which is a JavaScript implementation on the Graal/Truffle language implementation framework. We compared our new implementation against the original Kanon, which is based on checkpointing, and confirmed that our implementation improves program execution (and data collection) speed, and has sufficiently small overheads to reconstruct object graphs.},
annote = {refereed},
note = {}
}
@article{izawa2022jot,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick AND Youyou Cong},
title = {Threaded Code Generation with a Meta-Tracing JIT Compiler},
year = 2022,
journal = {Journal of Object Technology},
issn = {1660-1769},
pages = {2:1-11},
doi = {10.5381/jot.2022.21.2.a1},
note = {Presented at the ICOOOLPS 2021 workshop in July 2021.},
numpages = 11,
archivePrefix = {arXiv},
eprint = {2106.12496},
abstract = {Language implementation frameworks, e.g., RPython and Truffle/Graal, are practical tools for creating efficient virtual machines, including a well-functioning just-in-time (JIT) compiler. It is demanding to support multitier JIT compilation in such a framework for language developers. This paper presents an idea to generate threaded code by reusing an existing meta-tracing JIT compiler, as well as an interpreter design for it. Our approach does not largely modify RPython itself but constructs an effective interpreter definition to enable threaded code generation in RPython. We expect our system to be extended to support multilevel JIT compilation in the RPython framework. We measured the potential performance of our threaded code generation by simulating its behavior in PyPy. We confirmed that our approach reduced code sizes by 80 \% and compilation times by 60 \% compared to PyPy's JIT compiler on average, and ran about 7 \% faster than the interpreter-only execution.},
annote = {refereed},
note = {selected}
}
@inproceedings{izawa2025uist,
  author={Izawa, Yusuke and Kadomoto, Junichiro and Irie, Hidetsugu},
  booktitle={37th ACM Symposium on User Interfance and Software Technology (UIST)},
  title={VisMorph: A Live Programming Environment for Shape-Adaptive Computers},
  year={2025},
  volume={},
  number={},
  pages={},
  note = {selected},
  keywords={},
  doi={},
  annote    =	{refereed},
  note      =	{selected},
}
@InProceedings{izawa_et_al:LIPIcs.ECOOP.2025.16,
  author =	{Izawa, Yusuke and Masuhara, Hidehiko and Bolz-Tereick, Carl Friedrich},
  title =	{{A Lightweight Method for Generating Multi-Tier JIT Compilation Virtual Machine in a Meta-Tracing Compiler Framework}},
  booktitle =	{39th European Conference on Object-Oriented Programming (ECOOP 2025)},
  pages =	{16:1--16:29},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-373-7},
  ISSN =	{1868-8969},
  year =	{2025},
  volume =	{333},
  editor =	{Aldrich, Jonathan and Silva, Alexandra},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2025.16},
  URN =		{urn:nbn:de:0030-drops-233090},
  doi =		{10.4230/LIPIcs.ECOOP.2025.16},
  annote    =	{refereed},
  note      =	{selected},
  archivePrefix = {arXiv},
eprint    =     {http://arxiv.org/abs/2504.17460},
}
@inproceedings{izawa2024apsec,
  author={Izawa, Yusuke and Kadomoto, Junichiro and Irie, Hidetsugu and Sakai, Shuichi},
  booktitle={2024 31st Asia-Pacific Software Engineering Conference (APSEC)},
  title={Designing a Reactive Programming Language for Shape-Adaptive Computers},
  year={2024},
  volume={},
  number={},
  pages={452-456},
  note = {selected},
  keywords={Computers;Computer languages;Program processors;Shape;Focusing;Hardware;Complexity theory;Optimization;Software development management;Programming environments;Shape-Adaptive Computer;Compiler for a Specific Hardware;Reactive Programming Language},
  doi={10.1109/APSEC65559.2024.00058},
  annote    =	{refereed},
  note      =	{},
}
@inproceedings{izawa2023splashposter,
author = {Izawa, Yusuke and Kadomoto, Junichiro and Irie, Hidetsugu and Sakai, Shuichi},
title = {A Functional Reactive Programming Language  for Wirelessly Connected Shape-Changeable Chiplet-Based Computers},
year = 2023,
date = {2023-08-30},
doi = {10.1145/3618305.3623608},
isbn = {979-8-4007-0384-3/23/10},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
numpages = 2,
location = {Cascais, Portugal},
series = {SPLASH Companion 2023},
annote = {refereed},
}
@inproceedings{izawa2022pepm,
author = {Izawa, Yusuke and Masuhara, Hidehiko and Bolz-Tereick, Carl Friedrich},
title = {Two-level Just-in-Time Compilation with One Interpreter and One Engine},
year = 2022,
address = {Virtual},
howpublished = {},
booktitle = {The ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
series = {PEPM 2022},
date = {2022-01-17},
note = {\textbf{Refereed}. Short paper. 7 pages},
archivePrefix = {arXiv},
eprint = {2201.09268},
url = {https://popl22.sigplan.org/details/pepm-2022-papers/3/Two-level-Just-in-Time-Compilation-with-One-Interpreter-and-One-Engine},
abstract = {Modern, powerful virtual machines such as those running Java or JavaScript support multi-tier JIT compilation and optimization features to achieve their high performance. However, implementing and maintaining several compilers/optimizers that interact with each other requires hard-working VM developers. In this paper, we propose a technique to realize two-level JIT compilation in RPython without implementing several interpreters or compilers from scratch. As a preliminary realization, we created adaptive RPython, which performs both baseline JIT compilation based on threaded code and tracing JIT compilation. We also implemented a small programming language with it. Furthermore, we preliminarily evaluated the performance of that small language, and our baseline JIT compilation ran 1.77x faster than the interpreter-only execution. Furthermore, we observed that when we apply an optimal JIT compilation for different target methods, the performance was mostly the same as the one optimizing JIT compilation strategy, saving about 40 \% of the compilation code size.},
annote = {},
note = {}
}
@inproceedings{10.1145/3426422.3426977,
author = {Izawa, Yusuke and Masuhara, Hidehiko},
title = {Amalgamating Different JIT Compilations in a Meta-Tracing JIT Compiler Framework},
year = {2020},
date = {2020-11-17},
isbn = {9781450381758},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3426422.3426977},
abstract = {Most virtual machines employ just-in-time (JIT) compilers to achieve high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner.  In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework.  We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture.  We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Symposium on Dynamic Languages},
pages = {1–15},
numpages = {15},
keywords = {JIT compiler, RPython, meta-tracing JIT compiler, language implementation framework},
location = {Virtual, USA},
series = {DLS 2020},
note = {\textbf{Refereed}. 15 pages},
annote = {refereed},
note = {selected}
}
@inproceedings{masuhara2020live,
author = {Hidehiko Masuhara AND Shusuke Takahashi AND Yusuke Izawa AND Youyou Cong},
title = {Toward a Multi-Language and Multi-Environment Framework for Live Programming},
year = 2020,
url = {http://liveprog.org/live-2020/Toward-a-Multi-Language-and-Multi-Environment-Framework-for-Live-Programming/},
series = {Live 2020},
address = {Virtual},
booktitle = {Proceedings of the 6th Workshop on Live Programming},
numpages = 5,
pages = {1-5},
note = {\textbf{Refereed}. 5 pages},
abstract = {While applications of live programming are expanding to more practical and professional domains, most live programming environments (LPEs) are still developed for a single target language with an original code editor.  We propose an implementation framework for developing LPEs so that we can minimize efforts on implementing an LPE for a different target language and an existing code editor/IDE.  Our idea is to use a meta-JIT language implementation framework (e.g., Graal/Truffle and RPython) and LSP to separate core live programming implementations from language-specific and editor/IDE specific implementations.  This paper takes the Kanon live programming environment as a concrete example and discusses how we can design the framework to accommodate the features of Kanon.  Although the framework design is still underway, the paper presents a sketch of the framework APIs for separating language-specific functions and clarifies the requirements to LSP.},
annote = {refereed}
}
@inproceedings{10.1145/3328433.3328439,
author = {Izawa, Yusuke and Masuhara, Hidehiko and Aotani, Tomoyuki},
title = {Extending a Meta-Tracing Compiler to Mix Method and Tracing Compilation},
year = {2019},
date= {2019-04-02},
isbn = {9781450362573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3328433.3328439},
abstract = {Meta-interpreter-based just-in-time compiler frameworks provide a convenient way for language designers to implement efficient virtual machines. Those frameworks either employ tracing-based or method- (or partial evaluation) based strategies, which have their own pros and cons. This paper proposes an approach to enable both tracing- and method-based compilation so that the runtime can selectively apply an appropriate strategy to different parts of a program. The proposal basically extends a meta-tracing compiler to method-based compilation by roll backing at conditional branches, trace-splitting at loop entries, and not following at function calls. As a proof-of-concept, we implemented a tiny meta-tracing compiler in MinCaml by following the RPython's architecture and extended it to support both tracing- and method-based compilation.},
booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
articleno = {5},
numpages = {3},
pages = {1-3},
note = {\textbf{Refereed}. 3 pages},
keywords = {language implementation frameworks, tracing JIT compilation, RPython},
location = {Genova, Italy},
series = {Programming 2019},
annote = {refereed},
note = {}
}
@inproceedings{10.1145/3328433.3328466,
author = {Izawa, Yusuke},
title = {BacCaml: The Meta-Hybrid Just-in-Time Compiler},
year = {2019},
date= {2019-04-02},
isbn = {9781450362573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3328433.3328466},
abstract = {Meta-interpreter-based just-in-time compiler frameworks are useful to conveniently build a language runtime with reasonable execution performance.},
booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
articleno = {32},
numpages = {3},
pages = {1-3},
note = {\textbf{Refereed}. \textbf{Awarded [*]}. 3 pages},
location = {Genova, Italy},
series = {Programming 2019},
annote = {refereed},
note = {}
}
@inproceedings{izawa2019jssst,
organization = {{J}apan Society for Software Science and Technology ({JSSST})},
location = {Shibaura Institute of Technology, Tokyo, Japan},
editor = {Kei Ito},
year = {2019},
date = {2019-08-27},
booktitle = {Proceedings of the 36th JSSST Annual Conference},
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani AND Youyou Cong},
title = {A Stack Hybridization for Meta-hybrid Just-in-time Compilation},
pages = {No.~2-L},
pages = {1--9},
review = {false},
keywords = {PyPy, BacCaml, MinCaml, RPython},
url = {http://jssst.or.jp/files/user/taikai/2019/proceedings.html},
abstract = {Meta-interpreter-based language implementation frameworks, such as RPython and Truffe/Graal, are convenient tool for implementing state-of-the-art virtual machines. Those frameworks are classified into trace-based and method- (or ast-) based strategies. RPython uses a trace-based policy to compile straight execution paths, while Truffe/Graal leverages method invocation to compile entire method bodies. Each approach has its own advantages and disadvantages. The trace-based strategy is good at compiling pro- grams with many branching possibilities and able to reduce the size of compiled code, but it is weak at programs with varying control-flow. The method-based strategy is robust with the latter type of programs but it needs thorough method-inlining management to achieve excellent performance. To take advantage of both strategies, we propose a meta-hybrid compilation technique to integrate trace- and method-based compilations, as well as a proof-of-concept implementation called BacCaml. To achieve this goal, we develop a stack hybridization mechanism which makes it possible to coordinate trace- and method-based meta JIT compilation. In the implementation, we extend RPython's architecture and introduced a special syntax for realizing this system in a single interpreter definition.},
annote = {nonrefereed}
}
@article{伊澤侑祐2023,
  title={何者かになるということ},
  author={伊澤, 侑祐},
  journal={日本バーチャルリアリティ学会誌},
  volume={28},
  number={2},
  pages={23-24},
  year={2023},
  doi={10.18974/jvrsj.28.2_23},
  annote={misc},
  language={japanese},
}
@misc{10.1145/3759548,
title = {VMIL '25: Proceedings of the 17th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages},
author = {Stefan Marr AND Yusuke Izawa},
year = {2025},
isbn = {9798400721649},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
abstract = {Welcome to the 17th ACM SIGPLAN International Workshop on Virtual Machines and Intermediate Languages (VMIL 2025). VMIL aims to advance the state of the art in the design and implementation of programming systems, with a particular focus on virtual machines—broadly defined. Co-located with ICFP/SPLASH’25, the workshop took place in Singapore on October 15, 2025. The workshop featured two submission deadlines: the first for mature research and work-in-progress papers included in the proceedings, and the second for position papers, experience reports, new ideas, and emerging results. VMIL received twelve submissions this year: eight full-length research papers, one work-in-progress paper, and three position papers. An accomplished Program Committee evaluated submissions based on novelty, relevance, and contribution to the state of the art. Each research and work-in-progress paper received at least three reviews. In total, eight papers were accepted—four research papers, three work-in-progress papers, and one position paper for presentation. Accepted research and work-in-progress papers are also published in the ACM Digital Library. Submissions spanned a wide range of topics, including ahead-of-time and just-in-time compilation, interpreters, intermediate representations, developer tooling, and memory management. Anil Madhavapeddy delivered the keynote on post-POSIX IO interfaces. We thank the authors for their submissions, the Program Committee for their high-quality reviews, and all attendees for their participation. Yusuke Izawa, Shoaib Akram September 2025 VMIL Program Co-Chairs},
location = {Singapore, Singapore}
}
@misc{izawa2025-u-twente,
author = {Yusuke Izawa},
title = {A Lightweight Approach to Multi-Tier JIT Compiler VM in a Meta-Tracing Compiler Framework},
howpublished = {University of Twente Colloquium},
year = {2025},
month = {9},
annote = {invited}
}
@misc{izawa2025-hpi,
author = {Yusuke Izawa},
title = {A Lightweight Method for Generating Multi-Tier JIT Compilation Virtual Machine in a Meta-Tracing Compiler Framework (Extended Version of ECOOP 2025)},
howpublished = {Systems Design Research Meeting, Hasso-Plattner-Institute},
year = {2025},
month = {7},
annote = {invited}
}
@misc{izawa2025pro-invited,
language = {japanese},
author = {伊澤, 侑祐},
title = {Meta-Tracing JIT コンパイラの可能性: コンパイル方式の融合と多層JITコン
                  パイラの生成 (若手研究者招待講演)},
howpublished = {第153回プログラミング研究発表会},
year = {2025},
month = 3,
note = {\textbf{Invited Talk}},
annote = {invited}
}
@misc{izawa2024act-x-2,
language = {japanese},
author = {伊澤, 侑祐},
title = {汎用性と高性能を両立するハイブリッド型実行時コンパイラ},
howpublished = {JST ACT-X 第2回成果報告回},
year = {2024},
month = 4,
note = {Poster Presentation},
annote = {nonrefereed}
}
@misc{izawa2023pro,
author = {伊澤, 侑祐 AND 堀江 倫大 AND 緒方 一則 AND トレント スコット AND 千葉 立寛},
title = {マルチデバイス・クラウドシステムの実現に向けたCPU用コミュニケーションライブラリの活用},
year = {2023},
address = {函館, 日本},
language = {japanese},
howpublished = {情報処理学会プログラミング研究会 -- 第145回プログラミング研究発表会},
date = {2023-08-03},
url = {https://sigpro.ipsj.or.jp/pro2023-2/program/},
annote = {nonrefereed}
}
@misc{izawa2023morevms,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick},
title = {Interpreter Taming to Realize Multiple Compilations in a Meta-Tracing JIT Compiler Framework},
year = {2023},
address = {Tokyo, Japan},
howpublished = {The 7th MoreVMs workshop (MoreVMs'23)},
series = {MoreVMs'23},
date = {2023-03-13},
note = {\textbf{Refereed}},
url = {https://2023.programming-conference.org/home/MoreVMs-2023},
annote = {refereed}
}
@misc{izawa2022icooolps,
author = {Yusuke Izawa AND Hidehiko Masuhara},
title = {Taming an Interpreter for Threaded Code Generation with a Tracing JIT Compiler},
year = {2022},
address = {Berlin, Germany},
howpublished = {The 17th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS 2022)},
series = {ICOOOLPS 2022},
date = {2022-06-07},
note = {\textbf{Refereed}},
url = {https://2022.ecoop.org/home/ICOOOLPS-2022},
annote = {refereed}
}
@misc{takahashi2022trufle,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {Efficient Object Graph Recording with Truffle for Live Data-Structure Programming},
year = {2022},
address = {Berlin, Germany},
howpublished = {Truffle/GraalVM Languages Workshop (Truffle 2022)},
series = {Truffle 2022},
date = {2022-06-07},
note = {\textbf{Refereed}},
url = {https://2022.ecoop.org/home/truffle-2022},
annote = {refereed}
}
@misc{izawasigpx9-2022,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick},
title = {A wild (meta-)tracing baroque},
howpublished = {SIGPX9},
url = {https://sigpx.org/9/},
year = {2022},
month = mar,
date  = {2022-03-23},
annote = {nonrefereed}
}
@misc{izawatsuken-2022,
language = {japanese},
author = {伊澤, 侑祐},
title = {A Meta-JIT Compiler That Rules Them All},
howpublished = {通研共同プロジェクト「型主導コンパイルによる高性能高信頼ソフトウェア構成」研究発表会},
year = {2022},
month = mar,
date = {2022-03-18},
annote = {nonrefereed}
}
@misc{izawa2021act-x-2,
language = {japanese},
author = {伊澤, 侑祐},
title = {汎用性と高性能を両立するハイブリッド型実行時コンパイラ},
howpublished = {JST ACT-X 第5回領域会議},
year = {2021},
month = nov,
note = {Poster Presentation},
annote = {nonrefereed}
}
@misc{takahashi2021ipsj-pro-2,
language = {japanese},
author = {高橋, 修祐 AND 伊澤 侑祐 AND 増原 英彦 AND 叢 悠悠},
yomi = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {データ構造ライブプログラミングのための言語実現フレームワークに基づくオブジェクトグラフ収集手法},
howpublished = {情報処理学会第136回プログラミング研究会 PRO 2021-3-(5)},
month = nov,
date = {2021-11-01},
year = 2021,
url = {https://sigpro.ipsj.or.jp/pro2021-3/program/},
annote = {nonrefereed}
}
@misc{izawa2021ipsj-pro20213,
language={japanese},
author={伊澤, 侑祐 AND 堀江 倫大 AND 緒方 一則 AND 千葉 立寛},
yomi={Yusuke Izawa AND Mitihiro Horie AND Kazunori Ogata AND Tatsuhiro Chiba},
title={Java静的コンパイラを用いたQuarkusフレームワークの性能評価},
howpublished = {情報処理学会第136回プログラミング研究会 PRO 2021-3-(6)},
month=nov,
year=2021,
date={2021-11-01},
url={https://sigpro.ipsj.or.jp/pro2021-3/program/},
annote = {nonrefereed}
}
@misc{izawa2021icooolps,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick AND Youyou Cong},
title = {Threaded Code Generation with a Meta-tracing JIT Compiler},
year = {2021},
address = {Virtual},
howpublished = {The 16th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS 2021)},
series = {ICOOOLPS 2021},
date = {2021-07-13},
archivePrefix = {arXiv},
eprint = {2106.12496v4},
note = {\textbf{Refereed}},
url = {https://conf.researchr.org/track/ecoop-issta-2021/ecoop-issta-2021-icooolps},
annote = {refereed}
}
@misc{izawa2021act-x-1,
language = {japanese},
author = {伊澤, 侑祐},
title = {汎用性と高性能を両立するハイブリッド型実行時コンパイラ},
howpublished = {JST ACT-X 第4回領域会議},
year = {2021},
month = 6,
annote = {nonrefereed}
}
@misc{takahashi2021ipsj-pro,
language = {japanese},
author = {高橋, 修祐 AND 伊澤 侑祐 AND 増原 英彦 AND 叢 悠悠},
yomi = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {言語実現フレームワークに基づく汎言語的オブジェクトグラフ収集手法},
howpublished = {情報処理学会第135回プログラミング研究会 PRO 2021-2-(7)},
date = {2021-07-21},
year = 2021,
month = jul,
url = {https://sigpro.ipsj.or.jp/pro2021-2/program/},
annote = {nonrefereed}
}
@misc{izawa2021ppl-reproduction,
author = {Yusuke Izawa AND Hidehiko Masuhara},
title = {Amalgamating Different {JIT} Compilations in a Meta-tracing {JIT} Compiler Framework},
howpublished = {The 23nd JSSST Workshop on Programming and Programming Languages},
booktitle = {The 23nd JSSST Workshop on Programming and Programming Languages},
year = 2021,
month = mar,
note = {Reproduction of the DLS'20 talk at JSSST PPL},
url = {https://jssst-ppl.org/workshop/2021/},
annote = {nonrefereed}
}
@misc{izawa2021ppl,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {An Interpreter Design for Supporting Different {JIT} Compilations in RPython Framework},
howpublished = {The 23nd JSSST Workshop on Programming and Programming Languages},
url = {https://easychair.org/smart-program/PPL2021/},
note = {Poster Presentation},
year = {2021},
month = mar,
annote = {nonrefereed}
}
@misc{takahashi2021ppl,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {汎言語的ライブプログラミング環境のためのデータ構造解析手法},
howpublished = {The 23nd JSSST Workshop on Programming and Programming Languages},
url = {https://easychair.org/smart-program/PPL2021/},
note = {Poster Presentation},
year = {2021},
month = mar,
annote = {nonrefereed}
}
@misc{izawa2020act-x-1,
language = {japanese},
author = {伊澤, 侑祐},
title = {汎用性と高性能を両立するハイブリッド型実行時コンパイラ},
howpublished = {JST ACT-X 第3回領域会議},
year = {2020},
month = 12,
annote = {nonrefereed}
}
@misc{takahashi2020jssstppl,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {ライブプログラミング環境は多言語化/多開発環境化の夢を見るか},
howpublished = {The 37th JSSST Anual Conference. Japan Society for Software Science and Technology},
year = 2020,
month = 9,
note = {Poster Presentation},
url = {https://jssst2020.wordpress.com/program/},
annote = {nonrefereed}
}
@misc{izawa2020ppl,
author = {Yusuke Izawa AND Hidehiko Masuhara},
title = {Making different JIT Compilations Dancing to the Same Tune, Acting in the Meta-level},
howpublished = {The 22nd JSSST Workshop on Programming and Programming Languages},
year = 2020,
month = 3,
note = {Poster Presentation},
url = {https://easychair.org/smart-program/PPL2020/},
annote = {nonrefereed}
}
@misc{izawa2019kumiki,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani},
title = {Meta-hybrid JIT Compilation Approach for the Path-divergence Problem},
howpublished = {The Kumiki 6.0 Meeting},
year = 2019,
month = dec,
annote = {nonrefereed}
}
@misc{izawa2018ppl,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani},
title = {メタ混合 {JIT} コンパイラの提案},
howpublished = {The 20nd JSSST Workshop on Programming and Programming Languages},
year = 2018,
month = 3,
note = {Poster Presentation},
url = {https://jssst-ppl.org/workshop/2018/program.html},
annote = {nonrefereed}
}
